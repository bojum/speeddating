--- 
title: "How to Get More Matches in Speed Dating"
author: "Yingyu Cao (yc3713), Bo Jumrustanasan (pj2356), Michael Qi (zq2175)"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
---

# Introduction

```{r}
library(knitr)
library(kableExtra)
library(tidyverse)
```

```{r, eval = FALSE}
## to locally render the book
bookdown::render_book("index.Rmd")
browseURL("docs/index.html")
```


<!--chapter:end:index.Rmd-->

# Data sources

The dataset for our project is `speed dating` dataset provided by Anna Montoya. It is publicly available on [Data.com](https://data.world/annavmontoya/speed-dating-experiment) as an excel file. 

The data contains information about match and questionnaire from a speed dating experiment in 2002-2004 that was run by professors Ray Fisman and Sheena Iyengar from Columbia Business School. The primamry purpose of the collection was for their paper [Gender Differences in Mate Selection: Evidence From a Speed Dating Experiment](https://faculty.chicagobooth.edu/emir.kamenica/documents/genderDifferences.pdf). 

## Experimental Design

The experiment is design based on *Speed Dating* which is an event where participants have a four-minute conversation and decide if they want to meet each other again. They will get the other's contact information only if both parties "accept".

Subjects in the experiments were students in graduate and professional school at Columbia University during the time of the experiment. They learned about the event through mass e-mail and fliers on distributed on campus. They had to sign up for the event by providing the experimentors with their names and email addresses and completing a pre-event survey ononline website. 

There were 20 sessions of the experiment, all of which had the same setting. All participants were randomly assigned to one of the sessions. On the session day, participants who are unawared of the total number of participants on that day had to fill in a scorecard that contains 

* Spaces to write the ID number of each person they met
* Yes/No whether a subject wants to meet the person again
* Six attributes on which a subject was to rate the person they met. The attributes are:
    * Attractive
    * Sincere
    * Intelligent
    * Fun
    * Ambitious
    * Shared Interests
    
There were roughly the same number of female and male participants in each sessions. Subjects only had conversation with those of different genders. Female subjects would meet all male subjects in the session. The scorecard was to be filled after each four-minute conversation.

The day after the *Speed Dating* event, particiapants were asked to complete the follow-up online questionaire in order to obtain their matches. For more detail on the experiment procedure, please check out the [study](https://faculty.chicagobooth.edu/emir.kamenica/documents/genderDifferences.pdf).


## Data Description

The raw dataset from the source has 195 variables and 8378 rows. The number of rows do not represent the total number of participants in the experiment. The data provider had transformed the dataset by gathering to match some variables between a subject and each of its partner. We have further cleaned the dataset so that it includes only important variables (see more detail in data cleaning section). Variables in the analysis is summarized in the metadata below. 

```{r}
data_dict <- read.csv(file = "data/metadata_var.csv") %>% select(Variable, Description) 

data_dict %>% kable %>% kable_styling() %>% 
  kableExtra::scroll_box(width = "100%", height = "600px")
```

Participants were also asked to rate five (and six in some cases) attributes for themselves and for people they met (i) before the event (if applicable), (ii) a day after the event, and (iii) 2 weeks after the event. The variable names are in the form of `[attribute][#]_[#]`.

```{r}
read.csv(file = "data/metadata_attr.csv") %>% 
  kable %>% kable_styling() %>% 
  kableExtra::scroll_box(width = "100%", height = "600px")
```


For more information about the raw data and questionaire, see the [metadata](https://github.com/bojum/speeddating/blob/master/data/Speed%20Dating%20Data%20Key.doc?raw=true) from the dataset provider. 



<!--chapter:end:02-data.Rmd-->

# Data transformation

The raw dataset contains 195 variables with 8378 rows. Only a subset of 195 variables are included in our analysis (more detail for this step in data transformation section). 


Below is a script file that we use to clean the dataset.

```{r, eval = FALSE}

speed_dating <- raw_dat %>% 
  select(iid,wave,gender,age,race,from,field,field_cd,undergra,mn_sat,tuition,income,
         imprace,expnum,
         sports:yoga,
         attr1_1:shar1_1,                                             # exp weight to others-1
         attr1_s:shar1_s,                                             # exp weight to others-2
         attr3_1:amb3_1,                                              # self-evaluate-1 (self)-1
         attr3_s:amb3_s,                                              # self-evaluate-1 (self)-2
         attr5_1:amb5_1,                                              # self-evaluate-2 (others)-1
         wave,pid,met_o,match,dec_o,int_corr,samerace,age_o,race_o,
         pf_o_att:pf_o_sha,                                           # score to others
         attr_o:shar_o,like_o,prob_o,                                 # score received
         attr1_2:shar1_2,                                             # exp weight to others-3
         attr3_2:amb3_2,                                              # self-evaluate-1 (self)-3
         attr5_2:amb5_2,                                              # self-evaluate-2 (others)-2
         you_call,them_cal,
         attr1_3:shar1_3,                                             # exp weight to others-4
         attr3_3:amb3_3,                                              # self-evaluate-1 (self)-4
         attr5_3:amb5_3,                                              # self-evaluate-2 (others)-3
         attr:shar,like,prob
         ) 

# add indicator columns

# get feature values of the partner
for (i in 1:nrow(speed_dating)) {
  # for each row, get partner's id
  pid = speed_dating[i, 'pid']
  # add temporary columns that holds partner's location, field, sports, reading, movies
  speed_dating[i, 'plocation'] = speed_dating[which(speed_dating$iid == pid)[1], 'from']
  speed_dating[i, 'pfield'] = speed_dating[which(speed_dating$iid == pid)[1], 'field']
}

# append indicator columns for location, field, and income
speed_dating['samelocation'] <- if_else(speed_dating$from == speed_dating$plocation, 'Yes', 'No')
speed_dating['samefield'] <- if_else(speed_dating$field == speed_dating$pfield, 'Yes', 'No')

# get the feature values of all the hobbies of the partner
f <- function(x){
  tmp <- data.frame("holder" = 1:dim(speed_dating)[1])
  result <- data.frame("holder" = 1:dim(speed_dating)[1])
  for (i in 1:nrow(speed_dating)){
    pid = speed_dating[i, 'pid']
    tmp[i,1] <- speed_dating[which(speed_dating$iid == pid)[1], x]
  }
  for (i in 1:nrow(speed_dating)) {
    result[i,1] <- if_else((tmp[i,1] >=7 & speed_dating[i,x]>=7), 'Yes', 'No')
  }
  return(result)
}
# append the newly added columns to the original data frame
names = colnames(speed_dating %>% select(sports:yoga))
common_features <- as.data.frame(do.call(cbind,lapply(names, f)))
colnames(common_features)<- paste0('same',colnames(speed_dating %>% select(sports:yoga)))
speed_dating <- cbind(speed_dating, common_features)
speed_dating <- speed_dating[, !duplicated(colnames(speed_dating))]

# drop unecessary columns and missing data
drops = c('plocation', 'pfield')
keeps = append(colnames(speed_dating %>% select(sports:yoga)), c('samelocation', 'samefield'))
speed_dating <- speed_dating[complete.cases(speed_dating[,keeps]), ]
```

<!--chapter:end:03-cleaning.Rmd-->

# Missing values

```{r}
load("data/speed_dating.RData")
dat_missing <- speed_dating %>% 
  select(attr1_1:shar1_1,                                             # exp weight to others-1
         attr3_1:amb3_1,                                              # self-evaluate-1 (self)-1
         attr1_2:shar1_2,                                             # exp weight to others-3
         attr3_2:amb3_2,                                              # self-evaluate-1 (self)-3
         attr1_3:shar1_3,                                             # exp weight to others-4
         attr3_3:amb3_3,                                              # self-evaluate-1 (self)-4
         pid,match,dec_o,samerace,
         attr:shar,like,prob,                                         # score to others
         goal) %>% 
  rownames_to_column("id") %>% 
  gather(key,value,-id) %>% 
  mutate(missing=ifelse(is.na(value),"yes","no"),
         missing2=ifelse(missing=="yes",1,0))

tmp <- fct_reorder(dat_missing$id,-dat_missing$missing2,sum) %>% levels()
breaks_values <- tmp[seq(0,dim(speed_dating)[1],round(dim(speed_dating)[1]/4,-3))]

dat_missing %>% 
  ggplot(aes(x=fct_reorder(key,-missing2,sum),y=fct_reorder(id,-missing2,sum),fill=missing))+
  geom_tile()+
  scale_fill_manual(values=c("lightblue","grey50"))+
  scale_y_discrete(breaks=breaks_values,
                   labels=seq(0,dim(speed_dating)[1],round(dim(speed_dating)[1]/4,-3))[-1])+
  labs(x="variables",y="observations",title = "Missing Pattern")+
  theme(axis.text.x = element_text(angle=90,hjust = 1))
```

There are several columns that have the same missing patterns because these columns are answered at the same time. For example, the columns with the most missing values are the question about the expectation and self-evaluation regarding to six different attributes two days after the datings (`attr1_3:shar1_3` and `attr3_3:sinc3_3`).

<!--chapter:end:04-missing.Rmd-->

# Results


```{r, child = "Expectation.Rmd", eval = FALSE}

```

<!--chapter:end:05-results.Rmd-->

# Interactive component



<!--chapter:end:06-interactive.Rmd-->

# Conclusion


<!--chapter:end:07-conclusion.Rmd-->

## Q2: How female and male's self-evaluation and expectation differs?

```{r message=FALSE}
library(ggplot2)
library(tidyverse)
```

### Expectations
#### How does expectation change before and after datings?
```{r expectation-1}
gender_exp <- speed_dating %>% 
  select(iid,gender
         ,attr1_1:shar1_1                        # exp weight to others-1
         ,pid
         ,attr1_2:shar1_2                        # exp weight to others-3
         # ,attr1_3:shar1_3                        # exp weight to others-4
         )

titles <- c("Expectation by Gender (before)",
            "Expectation by Gender (one day later)",
            "Expectation by Gender (weeks later)")
time <- c("before","one day later","weeks later")
gender_exp_bar=data.frame()
for (i in 1:2) {
  gender_exp_tmp <- gender_exp %>% 
    drop_na() %>% 
    select(iid,gender,paste("attr1_",i,sep = ""):paste("shar1_",i,sep = "")) %>% 
    rename("Attractive"=paste("attr1_",i,sep = ""),
           "Sincere"=paste("sinc1_",i,sep = ""),
           "Intelligent"=paste("intel1_",i,sep = ""),
           "Fun"=paste("fun1_",i,sep = ""),
           "Ambitious"=paste("amb1_",i,sep = ""),
           "Shared_hobbies"=paste("shar1_",i,sep = "")) %>%
    mutate(gender = ifelse(gender == 0, "Female","Male"),time=time[i]) %>% 
    gather(key="attribute",value="weight",-iid,-gender,-time) %>% 
    unique()
  
  gender_exp_tmp$attribute <- factor(gender_exp_tmp$attribute)
  gender_exp_tmp$gender <- factor(gender_exp_tmp$gender)
  gender_exp_tmp$time <- factor(gender_exp_tmp$time)
  
  gender_exp_bar <- rbind(gender_exp_bar,gender_exp_tmp)
}

gender_exp_bar <- gender_exp_bar %>% group_by(gender,time,attribute) %>% 
  summarise(weight=mean(weight)) %>% 
  mutate(weight=weight/sum(weight)*100) %>% 
  ungroup()
gender_exp_bar %>% 
  ggplot(aes(x=gender,y=weight,fill=reorder(attribute,-weight)))+
  geom_bar(position="stack", stat="identity")+
  facet_wrap(gender_exp_bar$time)+
  labs(fill = "Attributes",title = "Expectaion to Partners (by Gender)")
```

By analyzing the expectation before and after the dating by gender, we found:

1. For both female and male, intelligence, sincerity and fun are important attributes they expected to see in their partners.

2. Female attached much more importance to ambition of their partners than male do, while male attached much more importance to attractivity of the partners than female do. 

3. There is no large difference of the expections after the datings. But the weight of attraction increased slightly in both female and male groups.

#### Does the changes last for a long time?

```{r expectation-2}
gender_exp <- speed_dating %>% 
  select(iid,gender
         ,attr1_1:shar1_1                        # exp weight to others-1
         ,pid
         ,attr1_2:shar1_2                        # exp weight to others-3
         ,attr1_3:shar1_3                        # exp weight to others-4
         )

titles <- c("Expectation by Gender (before)",
            "Expectation by Gender (one day later)",
            "Expectation by Gender (weeks later)")
time <- c("before","one day later","weeks later")
gender_exp_bar=data.frame()
for (i in 1:3) {
  gender_exp_tmp <- gender_exp %>% 
    drop_na() %>% 
    select(iid,gender,paste("attr1_",i,sep = ""):paste("shar1_",i,sep = "")) %>% 
    rename("Attractive"=paste("attr1_",i,sep = ""),
           "Sincere"=paste("sinc1_",i,sep = ""),
           "Intelligent"=paste("intel1_",i,sep = ""),
           "Fun"=paste("fun1_",i,sep = ""),
           "Ambitious"=paste("amb1_",i,sep = ""),
           "Shared_hobbies"=paste("shar1_",i,sep = "")) %>%
    mutate(gender = ifelse(gender == 0, "Female","Male"),time=time[i]) %>% 
    gather(key="attribute",value="weight",-iid,-gender,-time) %>% 
    unique()
  
  gender_exp_tmp$attribute <- factor(gender_exp_tmp$attribute)
  gender_exp_tmp$gender <- factor(gender_exp_tmp$gender)
  gender_exp_tmp$time <- factor(gender_exp_tmp$time)
  
  gender_exp_bar <- rbind(gender_exp_bar,gender_exp_tmp)
}

gender_exp_bar <- gender_exp_bar %>% group_by(gender,time,attribute) %>% 
  summarise(weight=mean(weight)) %>% 
  mutate(weight=weight/sum(weight)*100) %>% 
  ungroup()
gender_exp_bar %>% 
  ggplot(aes(x=time,y=weight,color=gender,group=gender))+
  geom_line()+
  geom_point()+
  facet_wrap(gender_exp_bar$attribute)+
  labs(color = "Attributes",title = "Expectaion to Partners (by Gender)")+
  theme(axis.text.x = element_text(angle=30,hjust = 1))
```

To check does the dating have a long-term influence on people's expectations towards their partners, we did an analysis basing on the observations who answered the questions two weeks after. From the graph we found that one-time dating only has a short-term influence on people's expectations towards their partners. As time pass by, their expectations come back to the level before the datings.

This finding is reasonable since they were only one-time datings. However, to get a conclusion about whether people's mind change after dating, we need to seperate the groups into matched and unmatched.

#### Does match influence changes in expectation?
```{r expectation and match}
gender_exp <- speed_dating %>% 
  select(iid,gender
         ,attr1_1:shar1_1                        # exp weight to others-1
         ,pid,match
         ,attr1_2:shar1_2                        # exp weight to others-3
         # ,attr1_3:shar1_3                        # exp weight to others-4
         )

titles <- c("Expectation by Gender (before)",
            "Expectation by Gender (one day later)",
            "Expectation by Gender (weeks later)")
time <- c("before","one day later","weeks later")
gender_exp_bar=data.frame()
for (i in 1:2) {
  gender_exp_tmp <- gender_exp %>% 
    drop_na() %>% 
    select(iid,gender,match,paste("attr1_",i,sep = ""):paste("shar1_",i,sep = "")) %>% 
    rename("Attractive"=paste("attr1_",i,sep = ""),
           "Sincere"=paste("sinc1_",i,sep = ""),
           "Intelligent"=paste("intel1_",i,sep = ""),
           "Fun"=paste("fun1_",i,sep = ""),
           "Ambitious"=paste("amb1_",i,sep = ""),
           "Shared_hobbies"=paste("shar1_",i,sep = "")) %>%
    mutate(gender = ifelse(gender == 0, "Female","Male"),
           match = ifelse(match == 1, "matched","unmatched"),
           time=time[i]) %>% 
    gather(key="attribute",value="weight",-iid,-gender,-time,-match) %>% 
    unique()
  
  gender_exp_tmp$attribute <- factor(gender_exp_tmp$attribute)
  gender_exp_tmp$gender <- factor(gender_exp_tmp$gender)
  gender_exp_tmp$time <- factor(gender_exp_tmp$time)
  gender_exp_tmp$match <- factor(gender_exp_tmp$match)
  
  gender_exp_bar <- rbind(gender_exp_bar,gender_exp_tmp)
}

gender_exp_bar <- gender_exp_bar %>% group_by(gender,time,match,attribute) %>% 
  summarise(weight=mean(weight)) %>% 
  mutate(weight=weight/sum(weight)*100) %>% 
  ungroup() %>% 
  spread(time,weight) %>% 
  mutate(change=`one day later`-before)

gender_exp_bar %>% 
  ggplot(aes(x=attribute,y=change,fill=attribute))+
  geom_bar(stat = "identity")+
  # geom_point()+
  facet_grid(gender_exp_bar$gender~gender_exp_bar$match)+
  labs(color = "Attributes",title = "Expectaion to Partners (by Gender and Match)")+
  theme(axis.text.x = element_text(angle=30,hjust = 1))
```

There is no obvious difference between the expections of matched group and unmatched groups, which means whether people are on a dating or not does not influence their expections to their partners (if they are not dating secretly or with another person except for the one they meet in this event).

### Self-evaluation
#### How does self-evaluation change before and after datings?
```{r self-evaluation}
gender_eva <- speed_dating %>% 
  select(iid,gender,
         attr3_1:amb3_1                         # self-evaluate-1 (self)-1
         ,pid
         ,attr3_2:amb3_2                        # self-evaluate-1 (self)-3
         # ,attr3_3:amb3_3                        # self-evaluate-1 (self)-4
         )

time <- c("before","one day later","weeks later")

gender_eva_bar=data.frame()
for (i in 1:2) {
  gender_eva_tmp <- gender_eva %>% 
    drop_na() %>%   
    select(iid,gender,paste("attr3_",i,sep = ""):paste("amb3_",i,sep = "")) %>% 
    rename("Attractive"=paste("attr3_",i,sep = ""),
           "Sincere"=paste("sinc3_",i,sep = ""),
           "Intelligent"=paste("intel3_",i,sep = ""),
           "Fun"=paste("fun3_",i,sep = ""),
           "Ambitious"=paste("amb3_",i,sep = "")) %>%
    mutate(gender = ifelse(gender == 0, "Female","Male"),time=time[i]) %>% 
    gather(key="attribute",value="score",-iid,-gender,-time) %>% 
    unique()
  
  gender_eva_tmp$attribute <- factor(gender_eva_tmp$attribute)
  gender_eva_tmp$gender <- factor(gender_eva_tmp$gender)
  gender_eva_tmp$time <- factor(gender_eva_tmp$time)
  
  gender_eva_bar <- rbind(gender_eva_bar,gender_eva_tmp)
}

tmp <- gender_eva_bar %>% 
  spread(time,score) %>% 
  mutate(change=`one day later`-before) %>% 
  group_by(gender,attribute,change) %>% 
  summarise(n=n()) %>% 
  mutate(n=ifelse(gender=="Female",-n,n))

breaks_values <- pretty(tmp$n)

tmp %>% 
  ggplot(aes(x=change,y=n,fill=gender))+
  geom_bar(stat = "identity")+
  facet_grid(~tmp$attribute)+
  scale_y_continuous(breaks = breaks_values,
                     labels = abs(breaks_values))+
  labs(fill = "Gender",
       title = "Self-evaluation Changes (by Gender)",
       y="frequency")+
  theme(axis.text.x = element_text(angle = 30, hjust = 1),legend.position="bottom")+
  coord_flip()

```

#### Does match influence changes in self-evaluation?
```{r self-evaluation and match}
gender_eva <- speed_dating %>% 
  select(iid,gender,
         attr3_1:amb3_1                         # self-evaluate-1 (self)-1
         ,pid,match
         ,attr3_2:amb3_2                        # self-evaluate-1 (self)-3
         ,attr3_3:amb3_3                        # self-evaluate-1 (self)-4
         )

time <- c("before","one day later","weeks later")

gender_eva_bar=data.frame()
for (i in 1:2) {
  gender_eva_tmp <- gender_eva %>% 
    drop_na() %>%   
    select(iid,gender,match,paste("attr3_",i,sep = ""):paste("amb3_",i,sep = "")) %>% 
    rename("Attractive"=paste("attr3_",i,sep = ""),
           "Sincere"=paste("sinc3_",i,sep = ""),
           "Intelligent"=paste("intel3_",i,sep = ""),
           "Fun"=paste("fun3_",i,sep = ""),
           "Ambitious"=paste("amb3_",i,sep = "")) %>%
    mutate(gender = ifelse(gender == 0, "Female","Male"),
           match = ifelse(match == 1, "matched","unmatched"),
           time=time[i]) %>% 
    gather(key="attribute",value="score",-iid,-gender,-time,-match) %>% 
    unique()
  
  gender_eva_tmp$attribute <- factor(gender_eva_tmp$attribute)
  gender_eva_tmp$gender <- factor(gender_eva_tmp$gender)
  gender_eva_tmp$time <- factor(gender_eva_tmp$time)
  gender_eva_tmp$match <- factor(gender_eva_tmp$match)
  
  gender_eva_bar <- rbind(gender_eva_bar,gender_eva_tmp)
}
  
tmp <- gender_eva_bar %>% 
  spread(time,score) %>% 
  mutate(change=`one day later`-before) %>% 
  group_by(gender,attribute,match,change) %>% 
  summarise(n=n()) %>% 
  mutate(n=ifelse(gender=="Female",-n,n))

breaks_values <- pretty(tmp$n)

tmp %>% 
  ggplot(aes(x=change,y=n,fill=gender))+
  geom_bar(stat = "identity")+
  facet_grid(tmp$match~tmp$attribute)+
  scale_y_continuous(breaks = breaks_values,
                     labels = abs(breaks_values))+
  labs(fill = "Gender",
       title = "Self-evaluation Changes (by Gender)",
       y="frequency")+
  theme(legend.position="bottom")+
  coord_flip()

```

There is no large difference in self-evaluation regrading to the five attributes (ambitious, attractive, fun, intelligent and sincere) between females and males or before and after the datings. Nor the matching results influence their self-evaluation.

#### Does the expectation influence whether or not they decide to date?
```{r decision and expectation}
gender_mat <- speed_dating %>% 
  select(iid,gender
         ,attr1_1:shar1_1                        # exp weight to others-1
         ,attr3_1:amb3_1                         # self-evaluate-1 (self)-1
         ,pid,match,dec_o,samerace,goal
         ,attr:shar,like,prob                                   # score to others
  ) %>% 
  drop_na() %>% 
  mutate(gender = ifelse(gender == 0, "Female","Male"),
         dec_o=ifelse(dec_o==0,"No","Yes"),
         goal=ifelse(goal==3|goal==4,"Dating","Other")
         )
  
gender_mat$gender <- factor(gender_mat$gender)
gender_mat$dec_o <- factor(gender_mat$dec_o)
gender_mat$goal <- factor(gender_mat$goal)
```

```{r decision and expectation-2, warning=FALSE}
tmp <- gender_mat %>% select(iid,gender,dec_o,samerace,
                      attr:shar,like,prob,goal) %>%                       # score to others
  mutate(score=(attr+sinc+intel+fun+amb+shar)*100/60) %>% 
  group_by(gender,goal,score,dec_o) %>% 
  summarise(n=n()) %>% 
  mutate(n=ifelse(dec_o=="Yes",n,-n))

breaks_values <- pretty(tmp$n)

tmp %>% 
  ggplot(aes(x=score,y=n,width=1,fill=dec_o))+
  geom_bar(stat = "identity")+
  facet_grid(tmp$gender~tmp$goal,scales = "free")+
  scale_y_continuous(breaks = breaks_values,
                     labels = abs(breaks_values))+
  scale_fill_discrete(name="decision")+
  labs(title = "Does people date with higher score people?",
       y="frequency")+
  theme(legend.position="bottom")+
  coord_flip()
```

If people made their decisions based on the score they gave, for people they said "yes", the score for them should be higher than for those they said "no". But according to the graph, there is no difference between the distribution of the score between "yes" and "no" groups, even if we seperate people by their goal of participating the event excpet for the female groups whose goal is dating. In the female groups whose goal is dating, they tent to date with people who had higher scores.

### What influence people decisions?

```{r decision}
gender_mat %>% select(iid,gender,dec_o,samerace,
                      attr:shar,goal,like,prob) %>%                       # score to others
  mutate(score=(attr+sinc+intel+fun+amb+shar)*100/60) %>% 
  ggplot(aes(like,score,color=gender))+
  geom_point()+
  labs(title = "Scores and Likes")
```

The graph above shows that score and a good impression (like) of a person has a positive relationship, which means if scores did not influence people's decisions, a good impression mattered little.

```{r fig.width=10,fig.height=4}
# prob: how likely do you think others will say yes to you?

tmp <- gender_mat %>% mutate(like=round(like)) %>% 
  group_by(gender,like,dec_o) %>% 
  summarise(n=n()) %>% 
  spread(dec_o,n) %>% 
  mutate(yn_ratio=Yes/No)
p1 <- tmp[!is.na(tmp$yn_ratio),] %>% 
  ggplot(aes(x=like,y=yn_ratio,color=gender))+
  geom_line()+
  geom_point()+
  scale_x_continuous(breaks = seq(0,10,2))+
  labs(x="like",y="yes-no ratio of decisions")
p2 <- tmp[!is.na(tmp$yn_ratio),] %>% 
  ggplot(aes(x=like,y=Yes+No,fill=gender))+
  geom_bar(stat="identity",position="dodge")+
  scale_x_continuous(breaks = seq(0,10,2))+
  labs(x="like",y="frequency")
gridExtra::grid.arrange(p1,p2,nrow=1,top="Likes Does not Influence Decisions")


tmp <- gender_mat %>% mutate(prob=round(prob)) %>% 
  group_by(gender,prob,dec_o) %>% 
  summarise(n=n()) %>% 
  spread(dec_o,n) %>% 
  mutate(yn_ratio=Yes/No)
par(mfrow=c(1,2))
p3 <- tmp[!is.na(tmp$yn_ratio),] %>% 
  ggplot(aes(x=prob,y=yn_ratio,color=gender))+
  geom_line()+
  geom_point()+
  scale_x_continuous(breaks = seq(0,10,2))+
  labs(x="probability of being chosen",y="yes-no ratio of decisions")
p4 <- tmp[!is.na(tmp$yn_ratio),] %>% 
  ggplot(aes(x=prob,y=Yes+No,fill=gender))+
  geom_bar(stat="identity",position="dodge")+
  scale_x_continuous(breaks = seq(0,10,2))+
  labs(x="probability of being chosen",y="frequency")
gridExtra::grid.arrange(p3,p4,nrow=1,top="Others' Opinions Influence Decisions")

```

From the graph, we confirmed that whether or not a person like his/her partner did not have a large influence on his/her decision, namely, they did date with someone they like best. Instead, they tended to choose those who might like them. For females, if they thought a male was 70% likely to say "yes" to themselves, they will also say "yes". For males, if they thought a female was 80% likely to say "yes" to themselves, they will also say "yes".

<!--chapter:end:Expectation.Rmd-->


## Question: Will backrgound and common interests influence the match? Which feature is the most influential?



To answer this question, we have to look at background and common interests seperately. Background includes three features: `race`, `from`, and `field`. We can do so by comparing the chance of matching by conditioning on whether they are from the same `race`, same `from` (location), and same `field`. 

Data Cleaning:

we would like to append 6 indicator columns that indicates whether this person and his/her partner share that feature in common (actually 5 because samerace is available in the original data). 

```{r, echo=FALSE}
library(ggplot2)
library(tidyverse)
library(jsonlite)
load('data/speed_dating.RData')

# get feature values of the partner
for (i in 1:nrow(speed_dating)) {
  # for each row, get partner's id
  pid = speed_dating[i, 'pid']
  # add temporary columns that holds partner's location, field, sports, reading, movies
  speed_dating[i, 'plocation'] = speed_dating[which(speed_dating$iid == pid)[1], 'from']
  speed_dating[i, 'pfield'] = speed_dating[which(speed_dating$iid == pid)[1], 'field']
}
# append indicator columns for location, field, and income
speed_dating['samelocation'] <- if_else(speed_dating$from == speed_dating$plocation, 'Yes', 'No')
speed_dating['samefield'] <- if_else(speed_dating$field == speed_dating$pfield, 'Yes', 'No')

# get the feature values of all the hobbies of the partner
f <- function(x){
  tmp <- data.frame("holder" = 1:dim(speed_dating)[1])
  result <- data.frame("holder" = 1:dim(speed_dating)[1])
  for (i in 1:nrow(speed_dating)){
    pid = speed_dating[i, 'pid']
    tmp[i,1] <- speed_dating[which(speed_dating$iid == pid)[1], x]
  }
  for (i in 1:nrow(speed_dating)) {
    result[i,1] <- if_else((tmp[i,1] >=7 & speed_dating[i,x]>=7), 'Yes', 'No')
  }
  return(result)
}
# append the newly added columns to the original data frame
names = colnames(speed_dating %>% select(sports:yoga))
common_features <- as.data.frame(do.call(cbind,lapply(names, f)))
colnames(common_features)<- paste0('same',colnames(speed_dating %>% select(sports:yoga)))
speed_dating <- cbind(speed_dating, common_features)
speed_dating <- speed_dating[, !duplicated(colnames(speed_dating))]

# drop unecessary columns and missing data
drops = c('plocation', 'pfield')
<<<<<<< HEAD
speed_dating <- select(speed_dating, -drops)
keeps = append(paste0('same',colnames(speed_dating %>% select(sports:yoga))), c('samelocation', 'samefield'))
=======
keeps = append(colnames(speed_dating %>% select(sports:yoga)), c('samelocation', 'samefield'))

>>>>>>> d070800f40e53d32091d2649e912691741d29e92
speed_dating <- speed_dating[complete.cases(speed_dating[,keeps]), ]

```

```{r}
save(speed_dating_q1, file = "data/speed_dating_q1.Rdata")
```

```{r, results='asis'}
# for mosaic plot 

# create a clean dataframe for each common feature
sameracedata = speed_dating %>% group_by(samerace, match) %>% summarise(Freq = n()) %>% ungroup() %>% mutate(samerace = if_else(samerace == 1, "Yes", "No")) %>% mutate(match = if_else(match == 1, "Yes", "No"))
samelocationdata = speed_dating %>% group_by(samelocation, match) %>% summarize(Freq = n()) %>% ungroup() %>% mutate(match = if_else(match == 1, "Yes", "No"))
samefielddata = speed_dating %>% group_by(samefield, match) %>% summarize(Freq = n()) %>% ungroup() %>% mutate(match = if_else(match == 1, "Yes", "No"))
samesportsdata = speed_dating %>% group_by(samesports, match) %>% summarize(Freq = n()) %>% ungroup() %>% mutate(match = if_else(match == 1, "Yes", "No"))
samereadingdata = speed_dating %>% group_by(samereading, match) %>% summarize(Freq = n()) %>% ungroup() %>% mutate(match = if_else(match == 1, "Yes", "No"))
samemoviesdata = speed_dating %>% group_by(samemovies, match) %>% summarize(Freq = n()) %>% ungroup() %>% mutate(match = if_else(match == 1, "Yes", "No"))
cat(
  paste(
  '<script>
    var sameracedata = ',toJSON(sameracedata),';
    var samelocationdata = ',toJSON(samelocationdata),';
    var samefielddata = ',toJSON(samefielddata),';
    var samesportsdata = ',toJSON(samesportsdata),';
    var samereadingdata = ',toJSON(samereadingdata),';
    var samemoviesdata = ',toJSON(samemoviesdata),';
  </script>'
  , sep="")
)
```

<script src="https://d3js.org/d3.v5.min.js"></script>
<svg width="910" height="550">		</svg>
<script>
  //initialize the svg
  var w = 800;
  var h = 500;
  var margin = {top: 25, right: 25, bottom: 25, left: 25};
  var innerWidth = w - margin.left - margin.right;
  var innerHeight = h - margin.top - margin.bottom;
  var dur = 500;
  
  var svg = d3.select("svg");
  svg.append("rect").attr("x", 0).attr("y", 0).attr("width", w).attr("height", h).attr("fill", "aliceblue");
  
  //initialize dataset
  var fill = "lightblue";
  var stroke = "#D0D3D4";
  var textfill = "#797D7F";
  
  var dataset = [{key: "race", value: sameracedata, f:"#2471A3", s:"#4B4C4D", tf: "#4B4C4D", axis: "Same Race", selected: "True", fw: "bold"}
                ,{key: "location", value: samelocationdata, f:fill, s:stroke, tf: textfill, axis: "from Same Location", selected: "False", fw: "normal"}
                ,{key: "field", value: samefielddata, f:fill, s:stroke, tf: textfill, axis: "Work in Same Field", selected: "False", fw: "normal"}
                ,{key: "sports", value: samesportsdata, f:fill, s:stroke, tf: textfill, axis: "Both love Sports", selected: "False", fw: "normal"}
                ,{key: "reading", value: samereadingdata, f:fill, s:stroke, tf: textfill, axis: "Both love Reading", selected: "False", fw: "normal"}
                ,{key: "movie", value: samemoviesdata, f:fill, s:stroke, tf: textfill, axis: "Both love Movies", selected: "False", fw: "normal"}];
  
  // use race feature as the initial plot
  var data = sameracedata;

  //manually transform to a mosaic plot
  function format(data){
    var offset = 50;
    var plotwidth = 350;
    var plotheight = 350;
    var bar2_x = (data[0].Freq+data[1].Freq)/d3.sum(data.map(d => d.Freq))*(plotwidth-5);
    var bar1_y = data[0].Freq/(data[0].Freq+data[1].Freq)*plotheight;
    var bar2_y = data[2].Freq/(data[2].Freq+data[3].Freq)*plotheight;
    return [{x: 2.5* offset, y: 1.5 * offset, w: bar2_x, h:bar1_y, f: "#D0D3D4", lx: bar2_x, t: "No", tx: 2.5 * offset+(bar2_x+5)/2, ty: 1.5 * offset -15},
            {x: 2.5* offset, y:bar1_y+1.5 * offset, w: bar2_x, h:plotheight-bar1_y, f: "#7B7D7D", t: "No", tx: 2.5 * offset-30, ty: bar1_y/2+1.5*offset},
            {x:bar2_x+5+2.5* offset, y:1.5 * offset, w: plotwidth-5-bar2_x, h: bar2_y, f: "#D0D3D4", t: "Yes", tx: 2.5 * offset+(bar2_x+5)+(plotwidth-(bar2_x+5))/2, ty: 1.5 * offset - 15},
            {x:bar2_x+5+2.5* offset, y: bar2_y+1.5 * offset, w:plotwidth-5-bar2_x, h: plotheight - bar2_y, f:"#7B7D7D", t: "Yes", tx:  2.5 * offset-30, ty: (plotheight - bar1_y)/2+bar1_y+1.5 * offset}];
  }
  
  //append the plot to a new group g
  var bars = svg.append("g")
                .attr("id", "plot")
                .attr("transform", `translate (${margin.left}, ${margin.top})`)
              .selectAll("rect")
                .data(format(data));
  
  // plot the initial plot
  bars.enter().append("rect")
      .attr("class", "bar")
      .attr("x", d => d.x)
      .attr("y", d => d.y)  
      .attr("width", d => d.w)
      .attr("height", d => d.h)
      .attr("fill",d => d.f)
      .attr("stroke", "#7B7D7D")
      .attr("stroke-width", "1");
      
  //add labels for axis
  svg.append("text")
      .attr("x", "50")
      .attr("y", "250")
      .attr("font-size","20")
      .attr("text-anchor","middle")
      .attr("font-family","helvetica")
      .attr("fill", "#313132")
      .attr("font-weight","bold")
      .text("Match");
                      
  var xlabel = svg.append("g")
                  .attr("id", "axis")
                  .attr("transform",`translate (${margin.left}, ${margin.top})`)
                .selectAll("text")
                  .data([dataset[0]], d=>d.key).enter()
                  .append("text")
                  .attr("x", "300")
                  .attr("y", "20")
                  .attr("font-size","20")
                  .attr("text-anchor","middle")
                  .attr("font-family","helvetica")
                  .attr("fill", "#313132")
                  .attr("font-weight","bold")
                  .text(d =>d.axis);        
  
  
  // add radio buttons
  var buttons1 = svg.append("g")
                    .attr("id", "buttons1")
                    .attr("class", "radio")
                    .attr("transform",  `translate (${margin.left}, ${margin.top})`)
                  .selectAll("circle")
                    .data(dataset, d=>d.key).enter().append("circle")
                    .attr("cx", "580")
                    .attr("cy", (d,i) => i*50+125)
                    .attr("r", "13")
                    .attr("fill", "aliceblue")
                    .attr("stroke", d=>d.s)
                    .attr("stroke-width", "3")
                    
  var buttons2 = svg.append("g")
                    .attr("id", "buttons2")
                    .attr("class", "radio")
                    .attr("transform",  `translate (${margin.left}, ${margin.top})`)
                  .selectAll("circle")
                    .data(dataset, d=>d.key).enter().append("circle")
                    .attr("cx", "580")
                    .attr("cy", (d,i) => i*50+125)
                    .attr("r", "6")
                    .attr("fill", d => d.f)
                    
  // add "Yes" and "No" text labels
  var labels = svg.select("g#plot").selectAll("text").data(format(data));
  
  labels.enter().append("text")
      .attr("id", "label")
      .attr("x", d=>d.tx)
      .attr("y", d=>d.ty)
      .attr("font-size","18")
      .attr("text-anchor","middle")
      .attr("font-family","helvetica")
      .attr("fill", "#313132")
      .text(d =>d.t); 
                
  //append text next to buttons
  var texts = svg.append("g")
                .attr("id", "texts")
                .attr("class", "radio")
                .attr("transform", `translate (${margin.left}, ${margin.top})`)
              .selectAll("text")
                .data(dataset, d=>d.key).enter().append("text")
                .attr("x", "610")
                .attr("y", (d, i) => i*50+130)
                .attr("fill", d=>d.tf)
                .attr("font-size","20")
                .attr("font-family", "helvetica")
                .attr("font-weight", d=>d.fw)
                .text(d=>d.key);
                    
  //switch event listeners if a button is clicked
  d3.selectAll("g.radio").selectAll("circle").on("click", function(){
    //update the chart
    update(format(d3.select(this).datum().value));
    //change the color of the radio buttons
    dataset.map(d => d.f = fill);
    dataset.map(d => d.s = stroke);
    dataset.map(d => d.tf = textfill);
    dataset.map(d => d.selected = "False");
    d3.select(this).datum().f = "#2471A3";
    d3.select(this).datum().s = "#4B4C4D";
    d3.select(this).datum().tf = "#4B4C4D";
    d3.select(this).datum().selected = "True";
    updatebutton(dataset);
    //change axis label
    xlabel.data([d3.select(this).datum()]).text(d=>d.axis);
  });
      
  // update method (using general update pattern)
  function update(data){
    var bars = svg.select("#plot").selectAll("rect").data(data);
    bars.transition().duration(dur)
        .ease(d3.easeLinear)
        .attr("x", d => d.x)
        .attr("y", d => d.y)  
        .attr("width", d => d.w)
        .attr("height", d => d.h);
    var labels = svg.selectAll("text#label").data(data);
    labels.transition().duration(dur)
        .ease(d3.easeLinear)
        .attr("x", d => d.tx)
        .attr("y", d => d.ty) 
  }
  
  // update method(for radio buttons)
  function updatebutton(dataset){
    buttons1.data(dataset).attr("stroke", d => d.s);
    buttons2.data(dataset).attr("fill", d=> d.f);
    texts.data(dataset).attr("fill", d=>d.tf).attr("font-weight", d=>d.fw);
  }
  
  d3.selectAll("g.radio").selectAll("circle").on("mouseover", handleMouseOver).on("mouseout", handleMouseOut);
  
  function handleMouseOver(){
    if(d3.select(this).datum().selected == "False"){
      d3.select(this).datum().f = "#4a9bd4";
      d3.select(this).datum().s = "#969696";
      d3.select(this).datum().tf = "#969696";
      d3.select(this).datum().fw = "bold";
      updatebutton(dataset);
    }
  }
  
  function handleMouseOut(){
    if(d3.select(this).datum().selected == "False"){
      d3.select(this).datum().f = fill;
      d3.select(this).datum().s = stroke;
      d3.select(this).datum().tf = textfill;
      d3.select(this).datum().fw = "normal";
      updatebutton(dataset);
    }
  }
</script>

We then look at all the available features that could be of common interest in the dataset, and see if any of those features heavily impacts the chances of getting matched.

```{r}
calc_diff <- function(x){
  tmp <- speed_dating %>% group_by_(x, 'match') %>% summarize(Freq = n()) %>% ungroup() %>% mutate(match = if_else(match == 1, "Yes", "No"))
  no_rate <- tmp[2,3]/(tmp[2,3]+tmp[1,3])
  yes_rate <- tmp[4,3]/(tmp[3,3]+tmp[4,3])
  return(yes_rate - no_rate)
}
cd_df <- do.call(rbind,lapply(paste0('same',colnames(speed_dating %>% select(sports:yoga))),calc_diff))*100
cd_df <- cbind(cd_df, names)

ggplot(cd_df,aes(x=Freq,y=fct_reorder(names,Freq)))+geom_point(color="blue")+ylab("")+xlab("Percent (%)")+ggtitle("Differences in Chance of Matching")
```


<!--chapter:end:Influential_Features.Rmd-->

